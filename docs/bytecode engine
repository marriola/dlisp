DLisp bytecode engine
===============================================================================


The data stack
===============================================================================

A data stack of Value objects is maintained by the bytecode engine for passing
parameters and returning values from functions. It is defined as:

std.container.slist!Value dataStack;


The dictionary
===============================================================================

Bytecode is stored in the dictionary, a 2 dimensional array of bytecode
instructions. Each function is assigned a number and a table of constants and
has a corresponding entry in the dictionary. It is defined as:

struct BytecodeFunction {
    Value[] constants;
    Instruction[] instructions;
}

BytecodeFunction[int] dictionary;


The program counter
===============================================================================

The bytecode engine maintains a program counter, which is defined as:

struct ProgramCounter {
    uint entry;         // dictionary entry
    uint entryCounter;  // instruction within dictionary entry
}


The call stack
===============================================================================

The bytecode engine also maintains a call stack of ProgramCounter objects.
Before a defined function calls another, it pushes a ProgramCounter object
pointing to the next instruction on the call stack. It is defined as:

std.container.slist!ProgramCounter callStack;

Calling builtin functions may be treated as an atomic operation and does not
involve the call stack.


Instructions
===============================================================================

Bytecode instructions are also stored internally as a struct, but may be
serialized for permanent storage.

struct Instruction {
    ubyte instruction;
    uint[] arguments;
}


builtin n
Binds all applicable parameters, popping them off the stack, and calls builtin
function n. The result will be pushed onto the stack.

fun n
Binds all applicable parameters, popping them off the stack, and calls defined
function n. The result will be pushed onto the stack.

pushconst n
Loads constant n from the constant table and pushes it onto the stack

pushvar n
Loads constant n from the call stack, retrieves its value and pushes it on the
stack. If the constant is not an identifier or it is undefined, an exception
is thrown.

jump n
Unconditionally jumps to instruction in within the current function

jumpif n
Pops a Value from the top of the stack. If it is T, control is transferred to
instruction n in the current function.

jumpifnot n
Pops a Value from the top of the stack. If it is not T, control is transferred
to instruction n in the current function.

return
Retrieves the last ProgramCounter from the call stack and jumps to the
instruction it points to. The token on top of the stack is the return value; if
the stack is empty, an exception is thrown.


Example
===============================================================================

builtin function IDs (tentative, for example purposes only)

=       0
*       1
1-      2

This function will be entered into the dictionary as defined function 0

1: (defun fact (n)
2:     (if (= n 0)
3:         1
4:         (* n (fact (1- n)))
5:     )
6: )

compiles to:

Constant table = [ 0: IdentifierToken("N"),
                   1: IntegerToken(0),
                   2: IntegerToken(1) ]

0:  pushconst 1     line 2  push IntegerToken(0)
1:  pushvar 0               push the value of N, which an argument was bound to at the time FACT was called
2:  builtin 0               (= n 0) empties the stack and pushes a BooleanToken onto the stack
3:  jumpifnot 6     
4:  pushconst 2     line 3  push IntegerToken(1)
5:  return                  return
6:  pushvar 0       line 4  push the value of N
7:  builtin 2               call builtin function 1-
8:  fun 0                   call defined function FACT. The value of N, which has been incremented and pushed back onto the stack, is bound again to the variable N in a new scope.
9:  pushparam 0             push the value of N
10: builtin 1               call builtin function *
11: return                  the result of that call is now the last thing on the stack, which is our return value. return.